[
  {
    "Id": "1068052",
    "ThreadId": "449944",
    "Html": "I have been looking over a great number of X12 parsers.  They all seem to parse to XML. and in some cases like OopFactory, can even write to a database.\r<br />\n<br />\nBut I am most familiar with Domain Driven Design.  In other words, at the end, I want to see my X12 810 as an Entity such as from the Entity Framework.<br />\n\r<br />\nThe reason I want this is so that I can then do validation and business processing directly from that entity, and then when it is all done, I can push it into the database as an Invoice.<br />\n\r<br />\nIn other words, I don't want a staging database, as then it's just another layer.  I think it is much easier to work with an Invoice Entity, then an EDI entity.<br />\n\r<br />\nBut of course, the EDI message still has to get parsed so it can be used to create such an entity, and the OopFactory X12 parser seems to be the best I have found so far.\r<br />\n<br />\nDo you think I am on the right track here?  Any suggestions for using OF to do the parsing part of this project?\r<br />\n<br />\nGreg<br />\n",
    "PostedDate": "2013-07-14T06:38:51.437-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1068126",
    "ThreadId": "449944",
    "Html": "oh boy!  since you asked...\r<br />\n<br />\nThis x12 parser and all the others you have reviewed ARE compatible with Domain Driven Design.  You are implying that they are not.\r<br />\n<br />\nBefore I can answer your question I must first explain that there are at least 4 levels (if not more) of x12 standardization:<br />\n<ul>\n<li><strong>Level  1 - the message format.</strong>  Each transaction set (there are over 300 of them) has a standard permissible syntax for a given version (4010 vs 5010).  this allows multiple parties to split these messages apart and rearrange them to their final destination without needing to know much about how it will be applied.</li>\n<li><strong>Level 2 - industry published implementation guides.</strong>  These will conform to level 1 standardization and has some  domain knowledge in that it species how to interpret different identifier codes within a specific industries application of that transaction set.  For example, 837P, 837I and 837D all conform to 837 X12 but are three different implementations.</li>\n<li><strong>Level 3 - a trading partner's implementation guide.</strong>  This looks very much like level 2 but is governed by a company rather than a standards organization.</li>\n<li>\n<strong>Level 4 – a trading agreement.</strong>  This is usually like level 3 but might contain any specifications related to the B2B transactions.<br />\n</li>\n</ul>\nBecause of this it is very easy to develop one mechanism for persisting all x12 to a relational database at the Level 1 awareness, but each subsequent level requires knowledge of the implementation guide(s) (there could be many across companies and versions) for that transaction set (thus the need for domain driven design).  That doesn’t make it difficult, only tedious.  And there are many companies willing to charge you an arm and a leg to help you with that.\r<br />\n<br />\nThe next sequential step in the pipeline after getting the data into a hierarchical structure (whether that be XML or the x12-aware objects) is to transform it into its domain model.  The Oopfactory.X12.Hippa.dll assembly is an EXAMPLE of this that uses XSLT transformations, but I found that most enterprise developers are quite weak in XSLT.  The database feature added early this year was to allow for the transformation to occur without knowing XSLT.  You can accomplish the same logically by using this tool to stage your data and performing the same logical transformation to domain specific tables using SQL.\r<br />\n<br />\nThe reason I said “the next sequential step” in the previous paragraph is to point out the order in which the message is processed.  Per domain driven design principles you should design your model first and then concern yourself later with how it will be hydrated from the persistence store that is provided to you (in this case an x12 file, though now you can do it from the database instead).  It sounds like this is where you are currently asking for some guidance.\r<br />\nI have actually spent years doing many implementations for clients using this pattern where I would transform the X12 using code into a domain model that I could act upon in code for validation etc., but there was a fatal flaw with this approach (which the database feature mitigates).  When I transform the x12 first and save the result to more closely represent my domain objects, there was a loss in fidelity because I had always parsed out much less than the standard defined (in this case for an 837 health claim which has 3 different 600 page documents to describe it).  Since I might have missed a few elements that I didn’t need at the time, that information was lost, because I didn’t store it to the database because my current domain model didn’t need it.  As requirements got added and we needed to know other segments that were getting sent in the files, it was tedious to reparse the files to find those previously ignored segments (and many times we didn’t do it).\r<br />\nWith the staging database, it is much easier to query and do analysis work on the full set of information sent to you.  Many clients don’t really know what they want from a file until you tell them what is getting sent in a file and this is easier for you to do if you don’t have to think about your domain model before getting your x12 into database.\r<br />\nSo, like you have stated a transformation has to be done.  But before you dismiss using the database for staging let me tell you the pros and cons of using the database versus using xslt directly.\r<br />\n<br />\nTransformation in XSLT:\r<br />\nPROS<br />\n<ul>\n<li>Requires less layers of abstraction (as you have stated).</li>\n<li>\nRequires less server storage for data that you will eventual save in another format<br />\n</li>\n</ul>\nCONS<br />\n<ul>\n<li>Very few enterprise develops are experienced and comfortable with XSLT code</li>\n<li>Any data not transformed by the XSLT will be lost (unless you reparse the files)</li>\n<li>\nIt is difficult to query for what is already in the files except for loading each file individual and running your XSLT.<br />\n</li>\n</ul>\nTransformation in SQL:\r<br />\nPROS<br />\n<ul>\n<li>Many more enterprise developers will be able to understand a SQL query statement that transforms one table format to another\r<br />\nThe full contents of the X12 file is ALWAYS parsed</li>\n<li>You can use the staging database for data-mining beyond what you initially needed for your domain object\r<br />\nCONS</li>\n<li>\nAn extra layer of transformation has to occurred (though this is written for you, so this is only a minus if you don’t like having another database floating around or you like XLST more than you like SQL)<br />\n</li>\n</ul>\nIf you don’t want your production process to have a staging database, you could use the SQL feature just for analysis tool and use the XSLT method to do your transformations.  There are plenty of examples of how to do this in the OopFactory.X12.Hippa project that is in the source code.\r<br />\nHopefully this gives you some ideas as to the best approach for you.<br />\n",
    "PostedDate": "2013-07-14T13:57:15.683-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1068131",
    "ThreadId": "449944",
    "Html": "BTW, I am not suggesting that you attempt to parse the entire X12 message into your domain model.  This would violate this design pattern since you are letting the persistence view dictate your domain.\r<br />\nBut it is much easier to rehydrate legacy data with previously ignored segments if you already have it all in a staging database.\r<br />\n<br />\nAlso, I didn't use Entity Framework because I wanted this tool to be ORM agnostic.  No one can agree on which one is the best to use and even Microsoft keeps re-inventing the wheel on this one.<br />\n",
    "PostedDate": "2013-07-14T14:14:03.413-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1068619",
    "ThreadId": "449944",
    "Html": "dstrubhar,\r<br />\n<br />\nThank you very much for your response.  You hit the nail on the head when you said &quot;It's not difficult, it just tedious!&quot;  This is my experience exactly.  I am still thinking about everything you have gone over in the above.  I appreciate your wisdom!\r<br />\n<br />\nGreg<br />\n",
    "PostedDate": "2013-07-15T12:31:44.873-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070224",
    "ThreadId": "449944",
    "Html": "Just to add my two cents. I think it is a bigger issue than just being tedious.\r<br />\n<br />\nI think this would take the project out of the hands of people who want to use this project as is without modifying the source code. The reason I say that is because not all trading partners use the same specs. If you look at an 810 spec from AT&amp;T and then look at one from WALMART they can be fairly different. This is because even though the segments and elements remain the same the purpose/identity of the data inside of an element may not be the same. So if your parsed out entity is going to end up being generic to accommodate this issue than you are back to square 1 and might as well have left it as it was.\r<br />\n<br />\nI like the fact that with this library I can determine who the trading partner was and then IF i need an entity i can choose how i want it parsed based on that specific trading partner.<br />\n",
    "PostedDate": "2013-07-18T15:25:34.943-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070232",
    "ThreadId": "449944",
    "Html": "I'm not sure why you say &quot;this would take the project out of the hands of people who want to use this project as is without modifying the source code&quot;.\r<br />\n<br />\nThis project is only meant to be a data layer.  So if you are using the same data as other 810 users, but just have different logic, than that's exactly what the library is intended for.\r<br />\n<br />\nYou would focus on the domain objects, you would need to map it to the x12 or edi objects in this library, but you can do this without modifying any source code at all.\r<br />\n<br />\nThere are even ways that you can redefine the x12 specification (by injecting your own) so that it can account for versions that might not be in the library (whether it is because it is an implementation of x12 instead of the standard or it is a future version not already embedded).\r<br />\n<br />\nThere are libraries outside the OopFactory.X12.dll that are examples of how to do the mapping, but it's not really part of the &quot;parser&quot; per se.  It's part of a possible implementation.\r<br />\n<br />\nThis project really isn't to do anything more than save you the trouble of how to parse x12 into its' intended hierarchical format.  In the end it's still just raw data with no implications of how that data will be consumed.  The OopFactory.X12.Hippa.dll assembly of examples of how to transform this into poco objects or into FO-XML for presentation, but again no real business logic.\r<br />\n<br />\nEveryone who uses this has to do some kind of transformation before the data is useful.  This might be transforming it to flat files (and using some other technology to consume and process the transaction), or to .NET business objects or to database tables. But the intent is not to remove the need to do the transformation, but at least remove all the upfront work with understanding the relationships between the segments in the files.  This can be done by &quot;<strong>using</strong>&quot; the library without &quot;<strong>changing</strong>&quot; the code.<br />\n",
    "PostedDate": "2013-07-18T15:42:34.943-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070234",
    "ThreadId": "449944",
    "Html": "I agree with you but perhaps it did not come across that way. \r<br />\n<br />\n<br />\n<strong>dstrubhar wrote:</strong><br />\n<blockquote>\nThis project really isn't to do anything more than save you the trouble of how to parse x12 into its' intended hierarchical format.  \n<br />\n</blockquote>\nThis is exactly what I appreciate it for. I don't want it giving me some object called obj810 with specific properties that i may or may not care about and that perhaps map into data with my trading partner that means something different. I prefer to define that on my own. \r<br />\n<br />\nI thought the OP was basically asking if this library could do that mapping for them and I was just saying it would be almost impossible to come up with something meaningful to everyone and not get 100 posts a day about how come this data parsed into a field called purchase order and it wasn't the purchase order in scenario xyz.<br />\n",
    "PostedDate": "2013-07-18T15:49:56.833-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]