[
  {
    "Id": "1285354",
    "ThreadId": "558897",
    "Html": "I am using the unbundling aspect of X12Parser, but noticed that it does not include SE transaction trailer segments in it's output. Tracing this back, I believe this is due to the fact that X12StreamReader.ReadNextTransaction() does not include the trailing SE segment:<br />\n<pre><code>        public X12FlatTransaction ReadNextTransaction()\n        {\n            StringBuilder segments = new StringBuilder();\n\n            string segmentString = ReadNextSegment();\n            string segmentId = ReadSegmentId(segmentString);\n            do\n            {\n                switch (segmentId)\n                {\n                    case &quot;ISA&quot;:\n                        _isaSegment = segmentString + _delimiters.SegmentTerminator;\n                        break;\n                    case &quot;GS&quot;:\n                        _gsSegment = segmentString + _delimiters.SegmentTerminator;\n                        break;\n                    case &quot;IEA&quot;:\n                    case &quot;GE&quot;:\n                        break;\n                    default:\n                        if (segmentId == &quot;ST&quot;)\n                            _transactionCode = SplitSegment(segmentString)[1];\n                        segments.Append(segmentString);\n                        segments.Append(_delimiters.SegmentTerminator);\n                        break;\n                }\n                segmentString = ReadNextSegment();\n                segmentId = ReadSegmentId(segmentString);\n            } while (!string.IsNullOrEmpty(segmentString) &amp;&amp; segmentId != &quot;SE&quot;); // transaction trailer segment\n\n            return new X12FlatTransaction(\n                CurrentIsaSegment,\n                CurrentGsSegment,\n                segments.ToString());\n        }</code></pre>\n\nTherefore, the TerminationTrailerSegment in X12Parser.ParseMultiple() does not get set. Afterward, when we serialize the unbundled loop back to X12, the SE segment does not get emitted.\r<br />\n<br />\nAs an example,\r<br />\n<br />\nOriginal:<br />\n<pre><code>REF*LU*484345\nLX*1\nSV1*HC:99214*60*UN*1*11**1\nDTP*472*RD8*20120921-20120921\nREF*6R*1134\nSE*32*000000248\nGE*1*248\nIEA*1*000000248</code></pre>\n\nUnbundled:<br />\n<pre><code>REF*LU*484345\nLX*1\nSV1*HC:99214*60*UN*1*11**1\nDTP*472*RD8*20120921-20120921\nREF*6R*1134\nGE*1*248\nIEA*1*000000248</code></pre>\n\nI need to ask advice about where best to remedy this. I think modifying ReadNextTransaction() will possibly introduce a lot of issues, as it is used in a lot of places. It's current semantics cannot be blindly changed without in depth knowledge. \r<br />\n<br />\nI can make the required modifications and send you a pull request, but wanted to seek advice on the matter first.<br />\n",
    "PostedDate": "2014-08-04T15:04:45.463-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1286578",
    "ThreadId": "558897",
    "Html": "As a stop gap, I implemented a custom ReadNextTransaction() in my helper class:<br />\n<pre><code>        protected void Initialize() {\n            dataStream.Seek(0, SeekOrigin.Begin);\n\n            X12StreamReader x12Reader = new X12StreamReader(dataStream, new UTF8Encoding());\n            X12Parser parser = new X12Parser(specFinder, false);\n            List&lt;Interchange&gt; interchanges = new List&lt;Interchange&gt;();\n\n            string segments = ReadNextTransaction(x12Reader);\n\n            while (!string.IsNullOrWhiteSpace(segments)) {\n                var iList = parser.ParseMultiple(segments);\n\n                if (iList != null &amp;&amp; iList.Count &gt; 0) {\n                    if (loopId.Trim().ToUpper() == &quot;ST&quot;) {\n                        interchanges.Add(iList.First());\n                    } else {\n                        interchanges.AddRange(parser.UnbundleByLoop(iList.First(), loopId));\n                    }\n                }\n\n                segments = ReadNextTransaction(x12Reader);\n            }\n\n            for (int i = 0; i &lt; interchanges.Count; i++) {\n                IDS.IO.TempFileStream stream = new IDS.IO.TempFileStream();\n                using (var writer = stream.GetStreamWriter(new UTF8Encoding())) {\n                    writer.Write(interchanges[i].SerializeToX12(newlines));\n                    writer.Flush();\n                }\n\n                stream.Flush();\n                stream.Rewind();\n\n                transactions.Add(stream);\n            }\n        }\n\n        protected string ReadNextTransaction(X12StreamReader x12Reader) {\n            StringBuilder segments = new StringBuilder();\n            char segTerminator = x12Reader.Delimiters.SegmentTerminator;\n            char elemSeparator = x12Reader.Delimiters.ElementSeparator;\n            string isa = x12Reader.CurrentIsaSegment;\n            string gs = x12Reader.CurrentGsSegment;\n\n            string segmentString = x12Reader.ReadNextSegment();\n            string segmentId = x12Reader.ReadSegmentId(segmentString);\n\n            do {\n                switch (segmentId) {\n                    case &quot;ISA&quot;:\n                        isa = segmentString;\n                        break;\n\n                    case &quot;GS&quot;:\n                        gs = segmentString;\n                        break;\n\n                    case &quot;IEA&quot;:\n                        break;\n\n                    case &quot;GE&quot;:\n                        break;\n\n                    default:\n                        segments.Append(segmentString);\n                        segments.Append(segTerminator);\n\n                        break;\n                }\n\n                segmentString = x12Reader.ReadNextSegment();\n                segmentId = x12Reader.ReadSegmentId(segmentString);\n\n            } while (!string.IsNullOrEmpty(segmentString) &amp;&amp; segmentId != &quot;SE&quot;);\n\n            if (segments.Length == 0) {\n                return string.Empty;\n            }\n\n            if (segmentId == &quot;SE&quot;) {\n                segments.Append(segmentString);\n                segments.Append(segTerminator);\n            }\n\n            StringBuilder sb = new StringBuilder(segments.Length + 512);\n\n            if (!string.IsNullOrWhiteSpace(isa)) {\n                sb.Append(isa);\n            }\n\n            if (!string.IsNullOrWhiteSpace(gs)) {\n                sb.Append(gs);\n                sb.Append(segTerminator);\n            }\n\n            sb.Append(segments);\n\n            if (!string.IsNullOrWhiteSpace(gs)) {\n                string[] gsElements = gs.Split(elemSeparator);\n                sb.AppendFormat(&quot;GE{1}{2}{1}{3}{0}&quot;, segTerminator, elemSeparator, &quot;1&quot;, gsElements[6]);\n            }\n\n            if (!string.IsNullOrWhiteSpace(isa)) {\n                string[] isaElements = isa.Split(elemSeparator);\n                sb.AppendFormat(&quot;IEA{1}1{1}{2}{0}&quot;, segTerminator, elemSeparator, isaElements[13]);\n            }\n\n            return sb.ToString();\n        }</code></pre>\n\nThis produces the desired result:<br />\n<pre><code>REF*LU*484345\nLX*1\nSV1*HC:99214*60*UN*1*11**1\nDTP*472*RD8*20120921-20120921\nREF*6R*1134\nSE*32*000000248\nGE*1*248\nIEA*1*000000248</code></pre>\n\n",
    "PostedDate": "2014-08-05T10:20:26.233-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]